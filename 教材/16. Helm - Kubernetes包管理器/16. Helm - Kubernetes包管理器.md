# Helm - Kubernetes包管理器

## 1. 为什么需要Helm？

Kubernetes 中的应用程序，都是由特定的资源描述组成，比如 Deployment、Service、ConfigMap 等等。我们将不同的资源描述文件各自保存在一个文件中，或者全部写在同一个文件中，然后使用 `kubectl apply –f` 部署应用程序。

```yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
    name: my-nginx-deploy
    labels:
        app: nginx
spec:
    replicas: 2
    selector:
        matchLabels:
            app: nginx
    template:
        metadata:
            labels:
                app: nginx
        spec:
            containers:
            - name: test-nginx
              image: nginx:alpine
              ports:
              - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: NodePort
  selector:
    app: nginx
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30007
```

如果应用程序只是由一个或几个简单的 Yaml 文件组成，上面的部署方式足够了。

而对于一些大型的复杂应用程序，会有很多类似上面这样的资源描述文件。例如微服务架构的应用程序，组成单个微服务的 Yaml 文件就可能多达十个，甚至几十个。如果有更新或者回滚应用程序的需求，需要修改和维护大量的 Yaml 文件，那么这种组织和管理应用程序的方式就显得有点力不从心了。

且由于对应用程序缺少版本化管理，对维护和更新 Kubernetes 上的应用程序提出了诸多的挑战，主要面临以下问题：

- 如何将这些 Yaml 文件作为一个整体管理

- 如何高效复用这些 Yaml 文件
- 不支持应用程序级别的版本化管理



## 2. Helm 介绍

Helm是一个 Kubernetes 的包管理工具。就像 Linux 系统中的包管理器，yum / apt 等，可以很方便的将打包好的 Yaml 文件部署到Kubernetes 集群之中。

我们可以把 Kubernetes 比作操作系统（Linux），那么 Helm 就好比 yum，apt-get，homebrew。

使用 Helm 可以方便我们部署和管理我们的应用。

Helm 的重要概念：

- **helm：**一个命令行客户端工具，主要用于创建、打包、发布和管理 Helm Chart。
- **Chart：**一系列 Kubernetes Yaml 文件的集合，将 Kubernetes Yaml  文件打包在一起，使用一条命令就可以部署应用程序。
- **Release：**基于 Chart 部署的实体，每个 Chart 可以部署一个或多个 release。



## 3. Helm v3.0 稳定版发布，一个重要的里程碑

2019年11月13日， Helm 团队发布 Helm v3 的第一个稳定版本。

Helm 3 以 Helm 2 的核心特性为基础，改进了 chart 存储库、版本管理、安全性等等。在这个版本中，Helm 维护者整合了来自社区的反馈和请求，以更好地满足 Kubernetes 用户和广泛的云原生生态系统的需求。

### 3.1 Helm v3 版本主要变化

1. Tiller 的删除，这也是最大的变化。

   ![](./images/helm_v2_v3.png)

2. Release 不再是全局资源，而是可以在不同的命名空间中重用。（换句话说，我们可以在不同的 namespace下部署同一个 chart。）

3. 为了更好地保持与其他包管理器的使用方式， `Helm CLI ` 命令更改为如下命令：

   ```
   helm delete` 更名为 `helm uninstall
   helm inspect` 更名为 `helm show
   helm fetch` 更名为 `helm pull
   ```

> 参考资料：
>
> https://blog.51cto.com/u_15127501/2655938



## 4. Helm 客户端

### 4.1 安装 Helm 客户端

本节将介绍如何安装 Helm CLI。 我们可以从源代码构建开始，安装 Helm，也可以直接使用预构建的二进制文件安装 Helm。  

一般推荐使用运行 Shell 脚本的方式安装 Helm，脚本会保证安装到最新版本的 Helm。

Helm 社区提供了通过操作系统的包管理器安装 Helm 的能力。 但这些并不受 Helm 项目的官方支持，也不被认为是可信的第三方。

同时 Helm 也可以运行在 Windows 操作系统之上。  

#### 4.1.1 From Script

Helm now has an installer script that will automatically grab the latest version of Helm and [install it locally](https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3).

You can fetch that script, and then execute it locally. It's well documented so that you can read through it and understand what it is doing before you run it.

```console
$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
$ chmod 700 get_helm.sh
$ ./get_helm.sh
```

Yes, you can `curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash` if you want to live on the edge.



#### 4.1.2 Through Package Managers

The Helm community provides the ability to install Helm through operating system package managers. These are not supported by the Helm project and are not considered trusted 3rd parties.



#####  4.1.2.1 From Scoop (Windows)

Members of the Helm community have contributed a [Helm package](https://github.com/ScoopInstaller/Main/blob/master/bucket/helm.json) build to [Scoop](https://scoop.sh/). This package is generally up to date.

```console
scoop install helm
```



##### 4.1.2.2 From Apt (Debian/Ubuntu)

Members of the Helm community have contributed a [Helm package](https://helm.baltorepo.com/stable/debian/) for Apt. This package is generally up to date.

```console
curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -
sudo apt-get install apt-transport-https --yes
echo "deb https://baltocdn.com/helm/stable/debian/ all main" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
sudo apt-get update
sudo apt-get install helm
```

> 参考资料：
>
> https://helm.sh/docs/intro/install/
>
> https://scoop.sh/



### 4.2 Helm 常用命令

以下为 Helm 的常用命令，当在 Kubernetes 中使用 Helm 时，使用下面列出的命令作为快速参考。 

| **命令**       | **描述**                                                     |
| -------------- | ------------------------------------------------------------ |
| helm create    | 创建一个chart                                                |
| helm get       | 下载 release 相关信息。可用子命令：all、hooks、manifest、notes、values |
| helm install   | 安装一个 Helm Chart                                          |
| helm list      | 列出当前命名空间中所有可用的 release                         |
| helm package   | 将 Chart 目录打包到压缩文件中                                |
| helm pull      | 从远程仓库中下载 Chart 到本地                                |
| helm repo      | 添加，列出，移除，更新和索引 chart 仓库。可用子命令：add、index、list、remove、update |
| helm search    | 根据关键字搜索 Chart。                                       |
| helm show      | 查看 Chart 的详细信息。可用子命令：all、chart、readme、values |
| helm uninstall | 卸载一个 release                                             |
| helm upgrade   | 更新一个 release                                             |
| helm version   | 查看 helm 客户端版本                                         |



#### Install and Uninstall Apps

Install an app:

```
helm install [app-name] [chart]
```

Install an app in a specific namespace:

```
helm install [app-name] [chart] --namespace [namespace]
```

Override the default values with those specified in a file of your choice:

```
helm install [app-name] [chart] --values [yaml-file/url]
```

Run a test installation to validate and verify the chart:

```
helm install [app-name] --dry-run --debug
```

Uninstall a release:

```
helm uninstall [release]
```



#### Perform App Upgrade and Rollback

Upgrade an app:

```
helm upgrade [release] [chart]
```

Instruct Helm to rollback changes if the upgrade fails:

```
helm upgrade [release] [chart] --atomic
```

Upgrade a release. If it does not exist on the system, install it:

```
helm upgrade [release] [chart] --install
```

Upgrade to a specified version:

```
helm upgrade [release] [chart] --version [version-number]
```

Roll back a release:

```
helm rollback [release] [revision]
```



#### Download Release Information

The **`helm get`** command lets you download information about a release.

Download all the release information:

```
helm get all [release]
```

Download all hooks:

```
helm get hooks [release]
```

Download the manifest:

```
helm get manifest [release]
```

Download the notes:

```
helm get notes [release]
```

Download the values file:

```
helm get values [release]
```

Fetch release history:

```
helm history [release] 
```



#### Add, Remove, and Update Repositories

The command [helm repo](https://phoenixnap.com/kb/helm-repo-add-update-remove) helps you manipulate chart repositories.

Add a repository from the internet:

```
helm repo add [repository-name] [url]
```

Remove a repository from your system:

```
helm repo remove [repository-name]
```

Update repositories:

```
helm repo update
```



#### List and Search Repositories

Use the **`helm repo`** and **`helm search`** commands to list and search Helm repositories. **`helm search`** also enables you to find apps and repositories in Helm Hub.

List chart repositories:

```
helm repo list
```

Generate an index file containing charts found in the current directory:

```
helm repo index
```

Search repositories for a keyword:

```
helm search repo [keyword]
```

Search Helm Hub:

```
helm search hub [keyword]
```



#### Release Monitoring

The **`helm list`** command enables listing releases in a Kubernetes cluster according to several criteria, including using regular (Pearl compatible) expressions to filter results. Commands such as **`helm status`** and **`helm history`** provide more details about releases.

List all available releases in the current namespace:

```
helm list
```

List all available releases across all namespaces:

```
helm list --all-namespaces
```

List all releases in a specific namespace:

```
helm list --namespace [namespace]
```

List all releases in a specific output format:

```
helm list --output [format]
```

Apply a filter to the list of releases using regular expressions:

```
helm list --filter '[expression]'
```

See the status of a specific release:

```
helm status [release]
```

Display the release history:

```
helm history [release]
```

See information about the Helm client environment:

```
helm env
```



#### Plugin Management

Install, manage and remove Helm plugins by using the **`helm plugin`** command.

Install plugins:

```
helm plugin install [path/url1] [path/url2] ...
```

View a list of all installed plugins:

```
helm plugin list
```

Update plugins:

```
helm plugin update [plugin1] [plugin2] ...
```

Uninstall a plugin:

```
helm plugin uninstall [plugin]
```



#### Chart Management

Create a directory containing the common chart files and directories (**c`hart.yaml`**, **`values.yaml`**, **`charts/`** and **`templates/`**):

```
helm create [name]
```

Package a chart into a chart archive:

```
helm package [chart-path]
```

Run tests to examine a chart and identify possible issues:

```
helm lint [chart]
```

Inspect a chart and list its contents:

```
helm show all [chart] 
```

Display the chart’s definition:

```
helm show chart [chart] 
```

Display the chart’s values:

```
helm show values [chart]
```

Download a chart:

```
helm pull [chart]
```

Download a chart and extract the archive’s contents into a directory:

```
helm pull [chart] --untar --untardir [directory]
```

Display a list of a chart’s dependencies:

```
helm dependency list [chart]
```



#### Get Help and Version Information

Display the general help output for Helm:

```
helm --help
```

Show help for a particular helm command:

```
helm [command] --help
```

See the installed version of Helm:

```
helm version
```



### 4.3 配置国内 Chart 仓库

#### 4.3.1 添加 Chart 仓库

- Helm 官方仓库。[Deprecated]

  ```shell
  # 添加 Helm 官方存储库
  helm repo add stable https://charts.helm.sh/stable
  ```

- 强烈推荐使用微软的 Chart 仓库，速度快，基本上官网有的 chart，这里都有。[Deprecated]

  ```shell
  # 添加 Azure 存储库
  helm repo add azure http://mirror.azure.cn/kubernetes/charts/
  ```

- Artifact Hub https://artifacthub.io/

#### 4.3.2 查看配置的存储库：

```shell
helm repo list
helm search repo azure
```

#### 4.3.3 删除存储库：

```shell
helm repo remove azure
```



## 5. Helm 的基本使用

### 5.1 使用 chart 部署应用

我们以 mysql 为例，讲解如何使用 helm 来安装 mysql。

```shell
# 添加 Helm Chart 仓库。
$ helm repo add stable https://charts.helm.sh/stable

# 查找 chart
$ helm search repo mysql
NAME                            	CHART VERSION	APP VERSION	DESCRIPTION                                 
stable/mysql                    	1.6.9        	5.7.30     	Fast, reliable, scalable, and easy...
...

# 查看 chart 详细信息
$ helm show chart stable/mysql
apiVersion: v1
appVersion: 5.7.30
description: Fast, reliable, scalable, and easy to use open-source relational
  database system.
home: https://www.mysql.com/
icon: https://www.mysql.com/common/logos/logo-mysql-170x115.png
keywords:
- mysql
- database
- sql
name: mysql
sources:
- https://github.com/kubernetes/charts
- https://github.com/docker-library/mysql
version: 1.6.9

# 安装 chart
$ helm install mysql stable/mysql

# 查看 release 状态
$ helm status mysql
NAME: mysql
LAST DEPLOYED: Thu May  5 21:02:06 2022
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
MySQL can be accessed via port 3306 on the following DNS name from within your cluster:
mysql.default.svc.cluster.local

To get your root password run:

    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default mysql -o jsonpath="{.data.mysql-root-password}" | base64 --decode; echo)

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il

2. Install the mysql client:

    $ apt-get update && apt-get install mysql-client -y

3. Connect using the mysql cli, then provide your password:
    $ mysql -h mysql -p

To connect to your database directly from outside the K8s cluster:
    MYSQL_HOST=127.0.0.1
    MYSQL_PORT=3306

    # Execute the following command to route the connection:
    kubectl port-forward svc/mysql 3306

    mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD}

```



### 5.2 安装前，自定义 chart 配置选项

上面部署的 mysql 并没有成功，这是因为并不是所有的chart都能按照默认配置运行成功，可能会需要一些环境依赖，例如 PV。

所以我们需要自定义chart配置选项，安装过程中有两种方法可以传递配置数据：

- --values（或-f）：指定YAML文件，已覆盖默认配置。可以多次指定，以最右边的文件优先。
- --set：在命令行上指定覆盖值。如果两者都用，--set 优先级更高。

**values.yaml 与 --set 的对比使用：**

![](./images/yaml-set.png)



#### 5.2.1 查看 values.yaml

- 我们可以将 chart 包下载下来查看详情：

  ```shell
  helm pull stable/mysql --untar
  ```

- 我们也可以使用命令 `helm show values stable/mysql`  查看 values.yaml

  ```shell
  # 查看 values.yaml
  $ helm show values stable/mysql
  ## mysql image version
  ## ref: https://hub.docker.com/r/library/mysql/tags/
  ##
  image: "mysql"
  imageTag: "5.7.30"
  
  strategy:
    type: Recreate
  
  busybox:
    image: "busybox"
    tag: "1.32"
  
  testFramework:
    enabled: true
    image: "bats/bats"
    tag: "1.2.1"
    imagePullPolicy: IfNotPresent
    securityContext: {}
  
  ## Specify password for root user
  ##
  ## Default: random 10 character string
  # mysqlRootPassword: testing
  
  ## Create a database user
  ##
  # mysqlUser:
  ## Default: random 10 character string
  # mysqlPassword:
  
  ## Allow unauthenticated access, uncomment to enable
  ##
  # mysqlAllowEmptyPassword: true
  
  ## Create a database
  ##
  # mysqlDatabase:
  
  ## Specify an imagePullPolicy (Required)
  ## It's recommended to change this to 'Always' if the image tag is 'latest'
  ## ref: http://kubernetes.io/docs/user-guide/images/#updating-images
  ##
  imagePullPolicy: IfNotPresent
  
  ## Additionnal arguments that are passed to the MySQL container.
  ## For example use --default-authentication-plugin=mysql_native_password if older clients need to
  ## connect to a MySQL 8 instance.
  args: []
  
  extraVolumes: |
    # - name: extras
    #   emptyDir: {}
  
  extraVolumeMounts: |
    # - name: extras
    #   mountPath: /usr/share/extras
    #   readOnly: true
  
  extraInitContainers: |
    # - name: do-something
    #   image: busybox
    #   command: ['do', 'something']
  
  ## A string to add extra environment variables
  # extraEnvVars: |
  #   - name: EXTRA_VAR
  #     value: "extra"
  
  # Optionally specify an array of imagePullSecrets.
  # Secrets must be manually created in the namespace.
  # ref: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
  # imagePullSecrets:
    # - name: myRegistryKeySecretName
  
  ## Node selector
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  nodeSelector: {}
  
  ## Affinity
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}
  
  ## Tolerations for pod assignment
  ## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  
  livenessProbe:
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3
  
  readinessProbe:
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 3
  
  ## Persist data to a persistent volume
  persistence:
    enabled: true
    ## database data Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    accessMode: ReadWriteOnce
    size: 8Gi
    annotations: {}
  
  ## Use an alternate scheduler, e.g. "stork".
  ## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
  ##
  # schedulerName:
  
  ## Security context
  securityContext:
    enabled: false
    runAsUser: 999
    fsGroup: 999
  
  ## Configure resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    requests:
      memory: 256Mi
      cpu: 100m
  
  # Custom mysql configuration files path
  configurationFilesPath: /etc/mysql/conf.d/
  
  # Custom mysql configuration files used to override default mysql settings
  configurationFiles: {}
  #  mysql.cnf: |-
  #    [mysqld]
  #    skip-name-resolve
  #    ssl-ca=/ssl/ca.pem
  #    ssl-cert=/ssl/server-cert.pem
  #    ssl-key=/ssl/server-key.pem
  
  # Custom mysql init SQL files used to initialize the database
  initializationFiles: {}
  #  first-db.sql: |-
  #    CREATE DATABASE IF NOT EXISTS first DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
  #  second-db.sql: |-
  #    CREATE DATABASE IF NOT EXISTS second DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
  
  # To enaable the mysql X Protocol's port
  # .. will expose the port 33060
  # .. Note the X Plugin needs installation
  # ref: https://dev.mysql.com/doc/refman/8.0/en/x-plugin-checking-installation.html
  mysqlx:
    port:
      enabled: false
  
  metrics:
    enabled: false
    image: prom/mysqld-exporter
    imageTag: v0.10.0
    imagePullPolicy: IfNotPresent
    resources: {}
    annotations: {}
      # prometheus.io/scrape: "true"
      # prometheus.io/port: "9104"
    livenessProbe:
      initialDelaySeconds: 15
      timeoutSeconds: 5
    readinessProbe:
      initialDelaySeconds: 5
      timeoutSeconds: 1
    flags: []
    serviceMonitor:
      enabled: false
      additionalLabels: {}
  
  ## Configure the service
  ## ref: http://kubernetes.io/docs/user-guide/services/
  service:
    annotations: {}
    ## Specify a service type
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
    type: ClusterIP
    port: 3306
    # nodePort: 32000
    # loadBalancerIP:
  
  ## Pods Service Account
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  serviceAccount:
    ## Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the mariadb.fullname template
    # name:
  
  ssl:
    enabled: false
    secret: mysql-ssl-certs
    certificates:
  #  - name: mysql-ssl-certs
  #    ca: |-
  #      -----BEGIN CERTIFICATE-----
  #      ...
  #      -----END CERTIFICATE-----
  #    cert: |-
  #      -----BEGIN CERTIFICATE-----
  #      ...
  #      -----END CERTIFICATE-----
  #    key: |-
  #      -----BEGIN RSA PRIVATE KEY-----
  #      ...
  #      -----END RSA PRIVATE KEY-----
  
  ## Populates the 'TZ' system timezone environment variable
  ## ref: https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html
  ##
  ## Default: nil (mysql will use image's default timezone, normally UTC)
  ## Example: 'Australia/Sydney'
  # timezone:
  
  # Deployment Annotations
  deploymentAnnotations: {}
  
  # To be added to the database server pod(s)
  podAnnotations: {}
  podLabels: {}
  
  ## Set pod priorityClassName
  # priorityClassName: {}
  
  
  ## Init container resources defaults
  initContainer:
    resources:
      requests:
        memory: 10Mi
        cpu: 10m
  ```



#### 5.2.2 手动创建 PV

- 通过查看 values.yaml，我们发现安装 mysql 需要 PersistentVolume 信息。

  ```yaml
  # values.yaml
  ## Persist data to a persistent volume
  persistence:
    enabled: true
    ## database data Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    accessMode: ReadWriteOnce
    size: 8Gi
    annotations: {}
  ```

- 使用 kubectl 命令手动创建 StorageClass 和 PersistentVolume。

  ```shell
  kubectl apply -f storage.yaml
  ```

  ```yaml
  ---
  # storage class manifest
  apiVersion: storage.k8s.io/v1
  kind: StorageClass
  metadata:
    name: local-storage
  provisioner: kubernetes.io/no-provisioner
  
  ---
  apiVersion: v1
  kind: PersistentVolume
  metadata:
    name: mysql-pv
  spec:
    capacity:
      storage: 10Gi
    volumeMode: Filesystem
    accessModes:
    - ReadWriteOnce
    persistentVolumeReclaimPolicy: Delete
    storageClassName: local-storage
    local:
      path: /tmp/mysql
    nodeAffinity:
      required:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname
            operator: In
            values:
            - shc-sma-cd74.hpeswlab.net
  ```

#### 5.2.3 重新部署 mysql

```shell
# 卸载 mysql
helm uninstall mysql
# 安装 mysql
helm install mysql stable/mysql -f config.yaml

# 我们也可以使用 --set，在命令行上指定覆盖值，没有指定的值，继续使用默认值（values.yaml）。
helm install mysql stable/mysql --set persistence.storageClass="local-storage" 
```

```shell
$ kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
mysql-7d99c88454-xwcfr   1/1     Running   0          6m17s
```

> **helm install 可以从多个来源安装 chart：**
>
> - chart存储库
> - 本地chart存档（helm install foo-0.1.1.tgz）
> - chart目录（helm install path/to/foo）
> - 完整的URL（helm install https://example.com/charts/foo-1.2.3.tgz）

### 5.3 升级、回滚和删除

当 chart 的新版本发布时，或者想更改当前 release 的配置时，可以使用 `helm upgrade` 命令。

```shell
helm upgrade --set imageTag=1.17 mysql stable/mysql

helm upgrade -f values.yaml mysql stable/mysql
```

如果在发布后没有达到预期的效果，则可以使用 `helm rollback ` 回滚到之前的版本。

例如将应用回滚到第一个版本：

```shell
# helm history mysql
helm rollback mysql 1
```

卸载应用，请使用 `helm uninstall` 命令：

```shell
helm uninstall mysql
```

查看历史版本配置信息

```shell
helm get values --revision=1 mysql
```



## 6. 构建一个 Helm Chart

在本节中，我们将先介绍一下  Helm Chart 的文件结构，然后是 Chart 模板的语法。最后开发自己的 Chart，并将其发布。

### 6.1 Helm Chart 的文件结构

我们可以使用 `helm create [name]` 命令创建 chart。我们可以看到 chart 的文件结构如下：

```shell
$ helm create mychart
Creating mychart
$ tree mychart/
helm-chart/
├── charts
├── Chart.yaml
├── templates
│   ├── deployment.yaml
│   ├── _helpers.tpl
│   ├── hpa.yaml
│   ├── ingress.yaml
│   ├── NOTES.txt
│   ├── serviceaccount.yaml
│   ├── service.yaml
│   └── tests
│       └── test-connection.yaml
└── values.yaml

```

- charts：此目录里存放这个 chart 所依赖的所有子chart。
- Chart.yaml：用于描述这个 chart 的基本信息，包括名字、描述信息以及版本等。
- templates： 此目录里存放所有的 yaml 模板文件。当执行 `helm install` 命令时，首先通过模板引擎渲染 templates 目录下的所有文件，然后将其发送给 Kubernetes。
- values.yaml ：包含了 templates 目录中 yaml 模板文件的默认值，在执行  `helm install` 或者 `helm upgrade` 命令时，我们可以覆盖这些默认值。
- NOTES.txt ：chart 的帮助信息，helm install 部署应用后展示给用户。例如：如何使用这个 chart、列出缺省的设置等。
- _helpers.tpl：自定义模板，便于在整个 chart 中重复使用

> 参考资料：
>
> https://helm.sh/docs/chart_template_guide/getting_started/



### 6. 2 Chart 模板

Helm最核心的就是模板，即模板化的 Kubernetes manifests 文件。

它本质上是一个Go template的模板。Helm在Go template模板的基础上，还会增加很多东西。如一些自定义的元数据信息、扩展的库以及一些类似于编程形式的工作流，例如条件语句、管道等等。这些东西都会使得我们的模板变得更加丰富。

我们已知 templates 目录下存放着所有的 Yaml 模板文件，但我们有了模板文件，怎么把我们的配置融入进去呢？用的就是这个values.yaml 文件。templates 目录和 values.yaml 这两部分内容其实就是 Helm Chart 的核心功能。

我们只需要对刚刚创建的 mychart 稍晚做一点点修改，就可使其成为一个可安装的 Chart 包。

```shell
# 删除所有默认生成的 Yaml 模板文件
$ rm -rf mychart/templates/*
# 创建一个 ConfigMap
$ vi mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: "Hello World"
```

然后我们通过 `helm install`命令来进行安装：

```shell
$ helm install full-coral ./mychart
NAME: full-coral
LAST DEPLOYED: Tue Nov  1 17:36:01 2016
NAMESPACE: default
STATUS: DEPLOYED
REVISION: 1
TEST SUITE: None
```

这样部署，其实与直接使用 `kubectl apply` 并没有什么两样。

使用如下命令可以看到 Yaml 模板文件被渲染过后的样子：

```shell
$ helm get manifest full-coral

---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: "Hello World"
```

可以看到，这与 templates 目录下的内容是一样的，包括名字、镜像等。



**添加一个简单的模板调用**

将`name:`硬编码到一个资源中不是很好的方式。名称应该是唯一的。因此我们可能希望通过插入 release 名称来生成名称字段。

```shell
# 修改 mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
```

现在 `name:`字段的值 `{{ .Release.Name }}-configmap`。

> 模板命令要括在 `{{` 和 `}}` 之间。

模板命令 `{{ .Release.Name }}` 将 release 名称注入到模板中。

> 参考资料：
>
> https://helm.sh/zh/docs/chart_template_guide/getting_started/



### 6.3 调试模板

调试模板可能很棘手，因为渲染后的模板发送给了Kubernetes API server，Kubernetes API server 可能会以格式化以外的原因拒绝创建YAML文件。

以下命令有助于调试：

- `helm lint`： 是验证chart是否遵循最佳实践的首选工具

  

- `helm install --dry-run --debug` 或 `helm template --debug`：帮助我们验证模板正确性。在执行 `helm install` 命令的时候带上 `--dry-run --debug` 调试参数，就可以根据 values.yaml 将Kubernetes 的模板文件渲染出来，而不会真正的去部署一个release。

  ```sh
  helm install web ./mychart --dry-run --debug
  ```

  

- `helm get manifest`: 查看已安装的模板文件。



### 6.4 内置对象

刚刚我们使用  `{{ .Release.Name }}`  将 release 的名称插入到 Deployment 的 Yaml 模板文件当中。这里的 `Release` 就是 Helm 的内置对象。

- `Release`：`Release` 对象描述了版本发布本身。包含了以下对象：

  - `Release.Name`： release 的名称

  - `Release.Namespace`： release 的 namespace

  - `Release.IsUpgrade`： 如果当前操作是升级或回滚，则将其设置为 true

  - `Release.IsInstall`： 如果当前操作是安装，则设置为 true。

  - `Release.Revision`： release 的修订版本号，从1开始累加

  - `Release.Service`： 负责渲染当前模板的服务。目前来说，这个值始终是 “Helm”

    

- `Values`： `Values` 对象是从 `values.yaml` 文件和用户提供的文件传进模板的。

  

- `Chart`：指的是 `Chart.yaml` 文件，通过 `Chart` 对象可以访问到 `Chart.yaml` 里的所有数据。比如 `{{ .Chart.Name }}-{{ .Chart.Version }}` 会打印出 `mychart-0.1.0`。

  

- `Files`：在 chart 中访问除了 Template 以外的文件。

  - `Files.Get`： 通过文件名获取文件。 （`.Files.Getconfig.ini`）
  - `Files.GetBytes`： 用字节数组代替字符串获取文件内容，适用于获取图片之类的文件
  - `Files.Glob`： 用给定的shell glob模式匹配文件名，返回文件列表
  - `Files.Lines`： 逐行读取文件内容
  - `Files.AsSecrets`： 使用Base 64编码字符串的形式返回文件内容
  - `Files.AsConfig`： 使用YAML格式返回文件内容

- `Capabilities`： 提供关于 Kubernetes 集群的相关信息

  - `Capabilities.APIVersions`：一个版本列表
  - `Capabilities.APIVersions.Has $version`： 判断集群中的版本 (比如,`batch/v1`) 或是资源 (比如, `apps/v1/Deployment`) 是否可用
  - `Capabilities.KubeVersion` 和`Capabilities.KubeVersion.Version`： Kubernetes 的版本号
  - `Capabilities.KubeVersion.Major`： Kubernetes 的主版本
  - `Capabilities.KubeVersion.Minor`： Kubernetes的次版本
  - `Capabilities.HelmVersion`： 包含Helm版本的详细信息，和 `helm version` 的输出一致
  - `Capabilities.HelmVersion.Version`： 当前Helm语义格式的版本
  - `Capabilities.HelmVersion.GitCommit`： Helm的git sha1值
  - `Capabilities.HelmVersion.GitTreeState`： Helm git树的状态
  - `Capabilities.HelmVersion.GoVersion`： 使用的Go编译器版本

- `Template`： 包含当前被执行的模板信息

  - `Template.Name`：当前模板的文件路径 (e.g. `mychart/templates/mytemplate.yaml`)
  - `Template.BasePath`：当前chart模板目录的路径 (e.g. `mychart/templates`)

> 参考资料：
>
> https://helm.sh/docs/chart_template_guide/builtin_objects/



### 6.5 Values 文件

Values 对象为 Chart 模板提供值，这个对象的值有4个来源：

1. chart 包中的 values.yaml 文件

2. 父 chart 包的 values.yaml 文件

3. 通过 helm install 或者 helm upgrade 的 `-f`或者 `--values`参数传入的自定义的 yaml 文件

4. 通过 `--set` 参数传入的值

以上列表有明确的顺序：默认使用`values.yaml`，可以被父chart的`values.yaml`覆盖，继而被用户提供values文件覆盖， 最后会被`--set`参数覆盖，优先级为`values.yaml`最低，`--set`参数最高。

**演示：**

1. values文件是普通的YAML文件。现在编辑`mychart/values.yaml`，删除`values.yaml`中的默认内容，仅设置一个参数：

   ```yaml
   # vi values.yaml 
   favoriteDrink: coffee
   ```

2. 现在我们就可以在模板中使用它了：

   ```yaml
   apiVersion: v1
   kind: ConfigMap
   metadata:
     name: {{ .Release.Name }}-configmap
   data:
     myvalue: "Hello World"
     drink: {{ .Values.favoriteDrink }}        # This Line.
   ```

3. 查看渲染结果：

   ```shell
   $ helm install geared-marsupi ./mychart --dry-run --debug
   install.go:158: [debug] Original chart version: ""
   install.go:175: [debug] CHART PATH: /home/bagratte/src/playground/mychart
   
   NAME: geared-marsupi
   LAST DEPLOYED: Wed Feb 19 23:21:13 2020
   NAMESPACE: default
   STATUS: pending-install
   REVISION: 1
   TEST SUITE: None
   USER-SUPPLIED VALUES:
   {}
   
   COMPUTED VALUES:
   favoriteDrink: coffee
   
   HOOKS:
   MANIFEST:
   ---
   # Source: mychart/templates/configmap.yaml
   apiVersion: v1
   kind: ConfigMap
   metadata:
     name: geared-marsupi-configmap
   data:
     myvalue: "Hello World"
     drink: coffee
   ```

> 参考资料：
>
> https://helm.sh/zh/docs/chart_template_guide/values_files/



### 6.6 管道与函数

#### 6.6.1 模板函数

到目前为止，我们已经知道了如何将信息传到模板中。 但是传入的信息并不能被修改。 有时我们希望以一种更有用的方式来转换所提供的数据。

让我们从一个最佳实践开始：可以通过调用模板指令中的`quote`函数把`.Values`对象中的字符串属性用引号引起来，然后放到模板中。

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ quote .Values.favorite.drink }}       # This Line.
  food: {{ quote .Values.favorite.food }}         # This Line.
```

模板函数的语法是 `functionName arg1 arg2...`。在上面的代码片段中，`quote .Values.favorite.drink` 调用了 `quote` 函数并传递了一个参数 (`.Values.favorite.drink`)。

Helm 有超过60个可用函数。其中有些通过 [Go模板语言](https://godoc.org/text/template)本身定义。其他大部分都是 [Sprig 模板库](https://masterminds.github.io/sprig/)。通过查阅文档，我们可以找到很多其他模板函数。

例如：

- 缩进：{{ .Values.resources | indent 12 }}
  - 缩进12个字符

- 大写：{{ upper .Values.resources }}
  - 将值全部转成大写

> 参考资料：
>
> https://masterminds.github.io/sprig/
>
> https://pkg.go.dev/text/template



#### 6.6.2 管道符

模板语言中还有一个强大的功能：管道。借鉴 UNIX 中管道的概念，管道是一个可以按照流式处理，并合并结果的工具。换句话说，管道符是按顺序完成一系列任务的方式。 我们现在尝试使用管道符重写上述示例：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | quote }}           # This Line.
  food: {{ .Values.favorite.food | quote }}             # This Line.
```

在这个示例中，并不是调用 `quote` 函数，而是倒置了命令。使用管道符 `|` 将参数 “发送” 给函数： `.Values.favorite.drink | quote`。

使用管道符还可以将多个函数链接在一起，例如：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | quote }}
  food: {{ .Values.favorite.food | upper | quote }}        # This Line.
```

模板会生成以下内容：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: trendsetting-p-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"                    # 注意原有的pizza现在已经被转换成了"PIZZA"
```



**使用`default`函数**

另外还有一个经常使用到的函数是default：`default DEFAULT_VALUE GIVEN_VALUE`，该函数允许在模板中指定默认值，以防止该值被忽略掉。

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}   # This Line.
  food: {{ .Values.favorite.food | upper | quote }}        
```

在实际的 chart 中，所有的静态默认值应该设置在 `values.yaml` 文件中，且不应该重复使用 `default` 命令 (否则会出现冗余)。然而这个`default` 命令很适合计算值，因为计算值不能声明在`values.yaml`文件中，比如：

```yaml
drink: {{ .Values.favorite.drink | default (printf "%s-tea" (include "fullname" .)) }}
```



**使用`lookup`函数**

`lookup` 函数可以用于在运行的集群中**查找**资源。lookup 函数简述为查找 `apiVersion, kind, namespace,name -> 返回资源或者资源列表`。

| parameter  | type   |
| :--------- | :----- |
| apiVersion | string |
| kind       | string |
| namespace  | string |
| name       | string |

`name` 和 `namespace` 都是选填的。

以下是可能的参数组合：

| 命令                                   | Lookup 函数                                |
| :------------------------------------- | :----------------------------------------- |
| `kubectl get pod mypod -n mynamespace` | `lookup "v1" "Pod" "mynamespace" "mypod"`  |
| `kubectl get pods -n mynamespace`      | `lookup "v1" "Pod" "mynamespace" ""`       |
| `kubectl get pods --all-namespaces`    | `lookup "v1" "Pod" "" ""`                  |
| `kubectl get namespace mynamespace`    | `lookup "v1" "Namespace" "" "mynamespace"` |
| `kubectl get namespaces`               | `lookup "v1" "Namespace" "" ""`            |

当 `lookup` 函数返回一个资源对象时，我们可以通过以下方式获取属性值。

下面的例子将返回`mynamespace`对象的annotations属性：

```
(lookup "v1" "Namespace" "" "mynamespace").metadata.annotations
```

当 `lookup` 函数返回一个对象列表时，可以通过 `items` 字段访问对象列表：

```go
{{ range $index, $service := (lookup "v1" "Service" "mynamespace" "").items }}
    {{/* do something with each service */}}
{{ end }}
```

当对象未找到时，会返回空值。可以用来检测对象是否存在。

`lookup` 函数通过 Helm 连接并查询 Kubernetes。当调用 Kubernetes API 服务发生错误时（比如缺少资源访问的权限），helm 的模板操作将会失败。

请注意，在运行 `helm template` 或者 `helm install|update|delete|rollback --dry-run` 时， 命令不会请求 Kubernetes API 服务。因此，`lookup` 函数在会返回空值或者空列表。



更多关于模板函数，可以参考：模板函数列表 https://helm.sh/zh/docs/chart_template_guide/function_list/

> 参考资料：
>
> https://helm.sh/zh/docs/chart_template_guide/function_list/
>
> https://helm.sh/docs/chart_template_guide/functions_and_pipelines/



### 6.7 流程控制

流程控制为模板提供了一种能力，能够处理更复杂的逻辑。Helm 模板语言提供以下流程控制语句：

- `if`/`else`， 用来创建条件语句
- `with`， 用来指定范围
- `range`， 提供类似 "for each" 类型的循环

除了这些之外，还提供了一些声明和使用命名模板的关键字：

- `define` 在模板中声明一个新的命名模板
- `template` 导入一个命名模板
- `block` 声明一种特殊的可填充的模板块

本节我们将主要讨论关于`if`，`with`，和 `range`。其他部分将会在 “命名模板” 章节进行说明。



#### if/else 条件判断

`if/else` 块是用于在模板中进行条件判断的，条件块的基本结构如下：

```go
{{ if PIPELINE }}
  # Do something
{{ else if OTHER PIPELINE }}
  # Do something else
{{ else }}
  # Default case
{{ end }}
```

注意此处我们讨论的是 **管道 （PIPELINE）**，而不是值。这样做的原因是想要清楚地说明，流程控制可以执行 ”管道“，而不仅仅是计算一个值。

如果执行管道（函数）得到以下值，对于条件判断来说，等同于 *false*：

- 布尔 false
- 数字 0
- 空字符串
- `nil` (空或null)
- 空集合 (`map`, `slice`, `tuple`, `dict`, `array`)

除此之外，对于条件判断来说，其他值等同于 *true*。



让我们先看一个简单的条件判断的示例。如果 `values.yaml` 中配置最喜欢的饮品是 `coffee`，则会添加另一个配置：`mug: "true"` （大杯咖啡）。

**示例：**

```yaml
# cat values.yaml 
favorite:
  drink: coffee
  food: pizza

# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{ if eq .Values.favorite.drink "coffee" }}mug: "true"{{ end }}
```

在上面的示例中，条件语句使用了 `eq` 运算符判断是否相等，除此之外，还支持 `ne`（not equal）、 `lt` （less than）、 `gt` （greater than）、 `and`、 `or` 等运算符。

通过模板引擎渲染后，我们会得到如下结果：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eyewitness-elk-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
  mug: "true"
```



#### 删除空格

我们观察刚刚的示例，其实并不便于阅读，我们可以格式化之前的例子，使其更易于阅读：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{ if eq .Values.favorite.drink "coffee" }}   
  mug: "true"
  {{ end }}
```

但当我们查看生成的 Yaml 时，看起来有点怪怪的：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: telling-chimp-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"

  mug: "true"
```

注意在 YAML 中有一个空行，为什么呢？当模板引擎运行时，它移除了 `{{` 和 `}}` 里面的内容，但是留下的空白完全保持原样。

YAML 认为空白是有意义的，因此删除空白变得很重要。幸运的是，Helm 模板有语法可以帮助我们处理此类问题。

- `{{- ` 表示向左删除空白（包括添加的横杠和空格）

` -}}` 表示向右删除空白。注意：删除空白，也会删除换行符

> 一定要确保 `-` 和其他命令之间有一个空格。 `{{- 3 }}` 表示 “删除左边空格并打印数字3”，而 `{{-3 }}` 表示打印数字 “-3”。

使用 `-` 语法，我们可以将模板修改如下，去掉新加的空白行：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{- if eq .Values.favorite.drink "coffee" }}           # This Line.
  mug: "true"
  {{- end }}
```

为了更好的理解 “删除空格”，我们调整上述内容，用一个`*`来代替一个空格符：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
**{{- if eq .Values.favorite.drink "coffee" }}
  mug: "true"
**{{- end }}
```

通过运行 `helm template` 查看模板被渲染后的结果：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: clunky-cat-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
  mug: "true"
```

但要特别注意以下场景，很容易就把换行符也删掉了：

```yaml
  food: {{ .Values.favorite.food | upper | quote }}
  {{- if eq .Values.favorite.drink "coffee" -}}
  mug: "true"
  {{- end -}}
```

输出：

```yaml
food: "PIZZA"mug:"true"
```

因为 `{{- if eq .Values.favorite.drink "coffee" -}}` 把两边的换行符行都删除了。



#### 缩进

我们也可以使用 ”缩进“ 的方式，而不是手打空格符的方式来格式化模板。有时，使用 ”缩进“ 的方式更容易告诉模板引擎应该如何缩进。使用 `indent` 方法进行缩进操作，例如：使用 `{{ indent 2 "mug:true" }}`。 

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{- if eq .Values.favorite.drink "coffee" }}          
  {{ indent 2 "mug:true" }}                           # This Line.
  {{- end }}
```



#### with - 修改使用范围

`with` 用来控制变量的范围。回想一下，`.` 是对当前作用域的引用。因此 `.Values` 就是告诉模板在当前作用域中查找 `Values` 对象。

`with` 的语法与 `if` 语法类似：

```yaml
{{ with PIPELINE }}
  # restricted scope
{{ end }}
```

使用 `with` 可以修改作用域。`with` 允许你为特定对象设定当前作用域 (`.`)。比如，我们已经在使用 `.Values.favorite`。 修改配置映射中的 `.` 的作用域指向 `.Values.favorite`：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
```

注意现在我们可以直接引用 `.drink` 和 `.food` 了，而不必限定他们。因为 `with` 语句将当前作用域 `.` 指向了 `.Values.favorite`。

`{{ end }}` 之后，`.` 的作用域被重置为上一个作用域。

但是这里有个注意事项，在限定的作用域内，无法使用 `.` 访问父作用域的对象。错误示例如下：

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ .Release.Name }}
  {{- end }}
```

这样会报错，因为 `Release.Name` 不在 `.` 限定的作用域内。但是如果对调最后两行就是正常的， 因为在 `{{ end }}` 之后作用域被重置了。

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
  release: {{ .Release.Name }}
```

或者，我们可以使用 `$` 从父作用域中访问 `Release.Name` 对象。当模板开始执行后， `$` 会被映射到根作用域，且执行过程中不会更改。 下面这种方式也可以正常工作：

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ $.Release.Name }}
  {{- end }}
```



#### range - 使用 `range` 操作循环

很多编程语言支持使用 `for` 循环，`foreach` 循环，或者类似的循环机制。 但在 Helm 的模板语言中，使用 `range` 关键字达到相同的功能。

开始之前，我们先在 `values.yaml` 文件添加一个披萨的配料列表：

```yaml
# values.yaml
favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions
```

现在我们有了一个 `pizzaToppings` 列表。修改模板把这个列表输出到 ConfigMap 中： 

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  toppings: |-
    {{- range $.Values.pizzaToppings }}
    - {{ . | title | quote }}
    {{- end }}    
  {{- end }}
```

让我们仔细看看 `toppings:` 列表。`range` 操作符会循环迭代 `pizzaToppings`列表。但我们可以发现一个有意思的事情。 就像 `with` 可以修改 `.` 的作用域，`range` 操作符也做了同样的事。每一次循环，`.` 都会被设置为当前的披萨配料。 也就是说，第一次 `.` 设置成了`mushrooms`，第二次迭代设置成了 `cheese`，等等。

我们可以直接发送 `.` 的值给管道，因此当我们执行 `{{ . | title | quote }}` 时，它会发送 `.` 到 `title`（首字母大写） ，然后发送到 `quote`。 如果执行这个模板，输出是这样的：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-dragonfly-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
  toppings: |-
    - "Mushrooms"
    - "Cheese"
    - "Peppers"
    - "Onions"    
```

`toppings: |-` 表示声明的是多行字符串。所以这个配料列表实际上不是 YAML 列表， 而是个大字符串。



我们也可以在模板中快速创建列表，然后循环迭代，Helm 模板的 `tuple` 可以很容易地实现该功能。

```yaml
  sizes: |-
    {{- range tuple "small" "medium" "large" }}
    - {{ . }}
    {{- end }}    
```

上述模板会生成以下内容：

```yaml
  sizes: |-
    - small
    - medium
    - large    
```

> 参考资料：
>
> https://helm.sh/zh/docs/chart_template_guide/control_structures/



### 6.8 变量

在模板中，变量很少被使用。但是我们可以使用变量简化代码，并可以更好地使用 `with` 和 `range`。

在之前的例子中，我们看到下面的代码会失败：

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ .Release.Name }}
  {{- end }}
```

`Release.Name` 不在 `with` 块的限制范围内。解决作用域问题的一种方法是将对象分配给可以不考虑当前作用域而访问的变量。

Helm 模板中，变量是对另一个对象的命名引用。遵循 `$name` 变量的格式且指定了一个特殊的赋值运算符：`:=`。 我们可以针对`Release.Name` 重写上述示例。

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- $relname := .Release.Name -}}             # This Line.
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ $relname }}                       # This Line.
  {{- end }}
```

注意在 `with` 块开始之前，赋值 `$relname := .Release.Name`。 那么在 `with` 块中，`$relname` 变量仍可获得版本名称。

运行之后会生成以下内容：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: viable-badger-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
  release: viable-badger
```

变量在 `range` 循环中特别有用。对于列表对象，可以获取到列表的索引和值：

```yaml
  toppings: |-
    {{- range $index, $topping := .Values.pizzaToppings }}
      {{ $index }}: {{ $topping }}
    {{- end }}    
```

注意先是 `range`，然后是变量，然后是赋值运算符，然后是列表。会将整型索引（从0开始）赋值给`$index`，并将值赋值给`$topping`。 执行模板后会生成：

```yaml
  toppings: |-
      0: mushrooms
      1: cheese
      2: peppers
      3: onions      
```

对于 key / value 数据结构的对象，可以使用 `range` 获取到 key 和 value。比如，可以通过 `.Values.favorite` 进行循环：

```yaml
# cat values.yaml
favorite:
  drink: coffee
  food: pizza

# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
```

第一次迭代，`$key` 会是 `drink` 且 `$val` 会是`coffee`，第二次迭代 `$key` 会是 `food` 且 `$val` 会是`pizza`。 运行之后会生成：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eager-rabbit-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
```

变量一般不是"全局的"。作用域是其声明所在的块。上面我们在模板的顶层赋值了 `$relname`。变量的作用域会是整个模板。 但在最后一个例子中 `$key` 和 `$val` 作用域会在 `{{ range... }}{{ end }}` 块内。

但有一个变量一直是全局的，即 `$` 。 `$` 变量一直是指向根的上下文。在循环中使用  `$`  会非常有用。

下面的例子，使用 `$` 变量，输出了 chart 的名称，版本等信息。

```yaml
{{- range .Values.tlsSecrets }}
apiVersion: v1
kind: Secret
metadata:
  name: {{ .name }}
  labels:
    # Many helm templates would use `.` below, but that will not work,
    # however `$` will work here
    app.kubernetes.io/name: {{ template "fullname" $ }}
    # I cannot reference .Chart.Name, but I can do $.Chart.Name
    helm.sh/chart: "{{ $.Chart.Name }}-{{ $.Chart.Version }}"
    app.kubernetes.io/instance: "{{ $.Release.Name }}"
    # Value from appVersion in Chart.yaml
    app.kubernetes.io/version: "{{ $.Chart.AppVersion }}"
    app.kubernetes.io/managed-by: "{{ $.Release.Service }}"
type: kubernetes.io/tls
data:
  tls.crt: {{ .certificate }}
  tls.key: {{ .key }}
---
{{- end }}
```

> 参考资料：
>
> https://helm.sh/zh/docs/chart_template_guide/variables/



### 6.9 命名模板

在本章节中，我们会看到如何定义命名模板，并在其他模板中使用命名模板。

在 "流程控制" 章节， 我们提到了声明和使用命名模板的关键字：`define`，`template`，和 `block`。在本章节中，我们将使用 `define`，`template`，和 `block`，并介绍 `include`方法，一种特殊用途的，类似于 `template` 的操作。

使用命名模板时，要特别注意，模板名称是全局的。如果我们有两个相同名称的模板，哪个 chart 最后加载就使用哪个模板。 

一个常见的命名惯例是用 chart 名称作为模板前缀：`{{ define "mychart.labels" }}`。使用特定 chart 名称作为前缀可以避免可能因为两个不同 chart 使用了相同名称的模板而引起的冲突。



#### `_helpers.tpl` 的文件

目前为止，我们已经使用了单个文件，且单个文件中包含了单个模板。但 Helm 的模板语言允许你创建命名的嵌入式模板， 这样就可以在其他模板中，按名称访问命名模板。

在编写命名模板之前，我们需要注意一下文件的命名规范：

- `templates/` 中的大多数文件被视为 Kubernetes manifest 文件 （ `NOTES.txt`除外 ）
- 以下划线 (`_`) 命名开头的文件则认为不是 Kubernetes manifest 文件，这些文件不会被模板引擎渲染为 Kubernetes 资源文件，但可以在其他 chart 模板中被引用。

实际上当我们第一次创建 `mychart` 时，会看到一个名为 `_helpers.tpl` 的文件，我们可以将命名模板定义在此文件中。



#### 用 `define` 和 `template` 声明和使用命名模板

`define` 操作允许我们在模板文件中创建一个命名模板，语法如下：

```yaml
{{ define "MY.NAME" }}
  # body of template here
{{ end }}
```

比如我们可以定义一个模板封装Kubernetes的标签：

```yaml
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
```

现在我们将模板嵌入到已有的 Yaml 文件中，然后使用关键字 `template` 使用命名模板：

```yaml
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
```

当模板引擎读取该文件时，它会存储 `mychart.labels` 的引用，直到 `template "mychart.labels"` 被调用。 然后会按行渲染模板，因此结果输出如下：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: running-panda-configmap
  labels:
    generator: helm
    date: 2016-11-02
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
```

按照惯例，Helm chart 将这些命名模板放置在局部文件中，一般是 `_helpers.tpl`。将刚定义的命名模板移到 `_helpers.tpl` 文件中：

```yaml
# _helpers.tpl
{{/* Generate basic labels */}}
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
```

按照惯例 `define` 方法会有个简单的文档块(`{{/* ... */}}`) 来描述要做的事。

尽管命名模板的定义在`_helpers.tpl`中，但我们仍可以在 `configmap.yaml` 中访问命名模板，因为**命名模板的名称是全局的**：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
```



#### 设置模板范围

在上面定义的模板中，我们没有使用任何对象，仅仅使用了方法。修改定义好的模板让其包含 chart 名称和版本号：

```yaml
{{/* Generate basic labels */}}
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
    chart: {{ .Chart.Name }}                  # This Line.
    version: {{ .Chart.Version }}             # This Line.
{{- end }}
```

如果使用此命名模板，我们将会得到以下错误：

```shell
$ helm install --dry-run moldy-jaguar ./mychart
Error: unable to build kubernetes objects from release manifest: error validating "": error validating data: [unknown object type "nil" in ConfigMap.metadata.labels.chart, unknown object type "nil" in ConfigMap.metadata.labels.version]
```

我们可以使用 `--disable-openapi-validation` 参数重新执行，查看渲染结果：

```shell
helm install --dry-run --disable-openapi-validation moldy-jaguar ./mychart
```

从渲染结果可以看出，这并不是我们想要的：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: moldy-jaguar-configmap
  labels:
    generator: helm
    date: 2021-03-06
    chart:               # This Line.
    version:             # This Line.
```

名称和版本号哪去了？为什么没有出现在我们定义的模板中。当一个（使用 `define` 创建的）命名模板被渲染时，会接收被 `template` 调用传入的内容。 在我们的示例中，命名模板的引用如下：

```yaml
{{- template "mychart.labels" }}
```

没有内容传入，所以模板中无法用 `.` 访问任何内容。但这个很容易解决，只需要传递一个范围给模板：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" . }}        # This Line.
```

注意在 `template` 调用末尾传入了 `.`，我们也可以传入 `.Values` 或 `.Values.favorite` 或其他需要的范围。但一定要是顶层范围。

再次运行 `helm install --dry-run --debug plinking-anaco ./mychart` 执行模板，然后得到：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: plinking-anaco-configmap
  labels:
    generator: helm
    date: 2021-03-06
    chart: mychart
    version: 0.1.0
```

现在 `{{ .Chart.Name }}` 解析为`mychart`，`{{ .Chart.Version }}` 解析为`0.1.0`。



#### `include` 方法

假设定义了一个命名模板如下：

```yaml
{{- define "mychart.app" -}}
app_name: {{ .Chart.Name }}
app_version: "{{ .Chart.Version }}"
{{- end -}}
```

现在假设我想把这个命名模板插入到模板的 `labels:` 部分和 `data:` 部分：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  labels:
    {{ template "mychart.app" . }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
{{ template "mychart.app" . }}
```

如果渲染这个，会得到以下错误：

```shell
$ helm install --dry-run measly-whippet ./mychart
Error: unable to build kubernetes objects from release manifest: error validating "": error validating data: [ValidationError(ConfigMap): unknown field "app_name" in io.k8s.api.core.v1.ConfigMap, ValidationError(ConfigMap): unknown field "app_version" in io.k8s.api.core.v1.ConfigMap]
```

我们可以使用 `--disable-openapi-validation` 参数重新执行，查看渲染结果：

```shell
helm install --dry-run --disable-openapi-validation measly-whippet ./mychart
```

从渲染结果可以看出，这并不是我们想要的：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: measly-whippet-configmap
  labels:
    app_name: mychart
app_version: "0.1.0"           # This Line.
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
app_name: mychart
app_version: "0.1.0"           # This Line.
```

注意两处的 `app_version` 缩进都不对，为啥？因为被替换的模板中文本是左对齐的，且 `template` 只是将数据简单地按行插入。

为了处理这个问题，Helm 提供了一个 `template` 的可选项，可以将命名模板的内容导入到管道中，然后传递给管道中的其他方法。

下面这个示例，使用 `indent` 正确地缩进了 `mychart.app` 模板：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  labels:
{{ include "mychart.app" . | indent 4 }}         # This Line.
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
{{ include "mychart.app" . | indent 2 }}         # This Line.
```

现在生成的 YAM L每一部分都可以正确缩进了：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-mole-configmap
  labels:
    app_name: mychart
    app_version: "0.1.0"
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
  app_name: mychart
  app_version: "0.1.0"
```

> 在 Helm 模板中使用 `include` 而不是 `template` 被认为是更好的方式，更好地处理 YAML 文档的输出格式。

> 参考资料：
>
> https://helm.sh/zh/docs/chart_template_guide/named_templates/



### 6.10 子chart和全局值

到目前为止，我们只使用了一个chart。但chart可以使用依赖，称为 ”子chart“（ *subcharts*），且有自己的 values.yaml 和模板。 本章节我们会创建一个子chart，并能看到访问模板中的值的不同方式。

在深入研究代码之前，需要了解一些子chart的重要细节：

1. 子chart被认为是“独立的”，意味着子chart从来不会显示依赖它的父chart。
2. 因此，子chart无法访问父chart的值。
3. 父chart可以覆盖子chart的值。
4. Helm 有一个 ”全局值“ （*global values*） 的概念，”全局值“  可以被所有 chart 访问。

在浏览完本节的示例之后，这些概念会变得更加清晰。



#### 6.10.1 创建子chart

为了做这些练习，我们可以从本指南开始时创建的 `mychart/` 开始，并在其中添加一个新的chart。

```shell
$ cd mychart/charts
$ helm create mysubchart
Creating mysubchart
# 注意，和以前一样，我们删除了所有的基本模板，然后从头开始。
$ rm -rf mysubchart/templates/*
```



#### 6.10.2 在子chart中添加 values.yaml 和模板

下一步，为 `mysubchart` 创建values.yaml 和模板。设置如下：

```yaml
# vi mychart/charts/mysubchart/values.yaml
dessert: cake
```

ConfigMap 模板：

```yaml
# vi mychart/charts/mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-cfgmap2
data:
  dessert: {{ .Values.dessert }}
```

因为每个子chart都是独立的 chart，可以单独测试 `mysubchart`：

```shell
$ helm install --generate-name --dry-run --debug mychart/charts/mysubchart
SERVER: "localhost:44134"
CHART PATH: /Users/mattbutcher/Code/Go/src/helm.sh/helm/_scratch/mychart/charts/mysubchart
NAME:   newbie-elk
TARGET NAMESPACE:   default
CHART:  mysubchart 0.1.0
MANIFEST:
---
# Source: mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: newbie-elk-cfgmap2
data:
  dessert: cake
```



#### 6.10.3 用父chart的 values.yaml 覆盖子chart 的值

`mychart` 是`mysubchart`的父 chart。这种关系是基于 `mysubchart` 在 `mychart/charts` 的文件目录下这一事实。

因为 `mychart` 是父级，可以在 `mychart` 指定配置并将配置推送到`mysubchart`。比如可以修改 `mychart/values.yaml`如下：

```yaml
favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

mysubchart:                      # This Line.
  dessert: ice cream             # This Line.
```

注意最后两行，在 `mysubchart` 中的所有指令会被发送到 `mysubchart` chart中。因此如果运行`helm install --dry-run --debug mychart`，会看到一项 `mysubchart` 的配置：

```yaml
# Source: mychart/charts/mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: unhinged-bee-cfgmap2
data:
  dessert: ice cream
```

现在，子chart的值已经被顶层的值覆盖了。

这里需要注意个重要细节。我们不会改变 `mychart/charts/mysubchart/templates/configmap.yaml` 模板的 Values 值。

```
{{ .Values.dessert }}  => {{ .Values.mysubchart.dessert }}
```

从模板的角度来看，值依然是在 `.Values.dessert`。当模板引擎传递值时，会设置作用域范围。 因此对于 `mysubchart`模板来说，`.Values` 中只提供专门用于 `mysubchart` 的值。

但是有时，我们确实希望某些值对所有模板都可用。这时，我们可以使用 “全局chart值”。



#### 6.10.4 全局Chart值

全局值是使用完全一样的名字，在所有的chart及子chart中都能访问的值。全局值，或者称之为全局变量，需要显示声明。

我们通过保留字 `global` 在`values.yaml`文件中设置全局值：

```yaml
favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

mysubchart:
  dessert: ice cream

global:                   # This Line.
  salad: caesar           # This Line.
```

然后我们可以用同样的方式 `{{ .Values.global.salad }}`，在 `mychart/templates/configmap.yaml`和`mysubchart/templates/configmap.yaml` 中访问全局值。

```yaml
# mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  salad: {{ .Values.global.salad }}          # This Line.
```

```yaml
# mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-cfgmap2
data:
  dessert: {{ .Values.dessert }}
  salad: {{ .Values.global.salad }}          # This Line.
```

> 防止滥用全局值，造成冲突。





#### 6.10.5 避免使用块

Go 模板语言提供了一个 `block` 关键字允许开发者提供一个稍后会被重写的默认实现。在Helm chart中， 块并不是用于覆盖的最好工具，因为如果提供了同一个块的多个实现，无法预测哪个会被选定。

建议改为使用`include`。



### 6.11 开发自己的 Chart

回家作业：创建以 Nginx 为 Deployment 的 Chart，并且重写 Nginx 的 index.html，输出 “ Hello World！”。

可以参考 How to Change Default Index Page on Nginx https://owlhowto.com/how-to-change-default-index-page-on-nginx/



## 7. 发布 Chart

大部分社区的 Helm Chart 都会发布在 [Artifact Hub](https://artifacthub.io/packages/search?kind=0)。但 Artifact Hub 并不是唯一的选择。

出于安全考虑，很多公司会架设自己的 chart 仓库。例如：

- **JFrog Artifactory**：商业解决方案，要钱。很多大公司都用 JFrog Artifactory，一站式解决方案，JFrog Artifactory 还可以存储 jar 包，容器镜像等。
- **GitHub Pages**：GitHub Pages 可以存储静态文件，我们可以利用 GitHub Pages 作为我们的 Helm Chart 仓库。
- **ChartMuseum Repository Server**：用 Golang 语言编写的开源项目。详情请见：[USING WITH LOCAL FILESYSTEM STORAGE](https://chartmuseum.com/docs/#using-with-local-filesystem-storage)



### 7.1 使用 GitHub Pages 创建一个公共的 Helm Chart 仓库 

#### 7.1.1 新建一个 github 仓库，例如 helm-chart

![](./images/create_git_repo.png)

#### 7.1.2 启用 GitHub Pages

1. 按下图所示，为 Github 仓库 helm-chart 开启 GitHub Pages 功能。

   ![](./images/gitpages.png)

2. 点击 Save 按钮后，我们将获得 GitHub Pages 的访问URL。例如：https://cainzhong.github.io/helm-chart/

   ![](./images/gitpages_url.png)



#### 7.1.3 克隆 github 仓库到本地

运行以下命令，将 github 仓库 helm-chart 克隆到本地。

```sh
git@github.com:cainzhong/helm-chart.git
```



#### 7.1.4 创建 helm chart

在 Github 仓库 helm-chart 路径下，创建 helm chart。

1. 运行以下命令，创建一个 helm chart

   ```sh
   helm create helm-chart
   # 删除默认的模板文件
   rm .\templates\*.yaml
   ```

2. 添加模板文件 configmap.yaml

   ```yaml
   # vi .\templates\configmap.yaml
   apiVersion: v1
   kind: ConfigMap
   metadata:
     name: {{ .Release.Name }}-configmap
   data:
     myvalue: "Hello World"
     {{- with .Values.favorite }}
     drink: {{ .drink | default "tea" | quote }}
     food: {{ .food | upper | quote }}
     toppings: |-
       {{- range $.Values.pizzaToppings }}
       - {{ . | title | quote }}
       {{- end }}    
     {{- end }}
   ```

3. 修改 values.yaml

   ```yaml
   # vi values.yaml
   favorite:
     drink: coffee
     food: pizza
   pizzaToppings:
     - mushrooms
     - cheese
     - peppers
     - onions
   ```

4. 测试 Helm Chart

   ```sh
   $ helm lint ./helm-chart
   ==> Linting ./helm-chart/
   [INFO] Chart.yaml: icon is recommended
   
   1 chart(s) linted, 0 chart(s) failed
   ```

5. 打包 Helm Chart

   ```sh
   $ helm package ./helm-chart
   Successfully packaged chart and saved it to: ../helm-chart/helm-chart-0.1.0.tgz
   ```

6. 创建 Helm chart 仓库索引（Helm chart repository index）

   ```sh
   helm repo index --url https://cainzhong.github.io/helm-chart/ ./helm-chart
   ```

   > Helm chart 仓库的主要特征是存在一个名为 index.yaml 的特殊文件，该文件包含所有 helm chart 包的列表，以及允许检索和验证这些包的元数据。 

#### 7.1.5 将代码推送至 Github

```sh
git add . && git commit -m "Initial commit" && git push origin
```

至此，我们已经成功将 helm-chart 发布至 GitHub Pages。可以将我们的 Helm Chart 分享给其他人使用。



#### 7.1.6 使用 Helm Chart

运行以下命令安装 Helm Chart。

```sh
# 添加 helm chart 仓库
$ helm repo add cainzhong https://cainzhong.github.io/helm-chart/

# 查询 helm chart 仓库
$ helm search repo cainzhong
NAME                	CHART VERSION	APP VERSION	DESCRIPTION                
cainzhong/helm-chart	0.1.0        	1.16.0     	A Helm chart for Kubernetes

# 安装 helm chart
$ helm install north-star cainzhong/helm-chart
NAME: north-star
LAST DEPLOYED: Fri May  6 22:01:19 2022
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Thank you for installing helm-chart.

Your release is named north-star.

To learn more about the release, try:

  $ helm status north-star
  $ helm get all north-star
```



> 参考资料：
>
> https://helm.sh/docs/topics/chart_repository/
>
> Create a public Helm chart repository with GitHub Pages
>
> https://medium.com/@mattiaperi/create-a-public-helm-chart-repository-with-github-pages-49b180dbb417



## 8. Helm 插件

在本章中，我们将讨论如何通过插件增强 Helm 功能。

插件可以向 Helm 添加额外的功能，与 Helm CLI 无缝集成，帮助用户完成特殊的工作流。网上有很多常用的第三方插件。此外，使用插件可以非常方便的帮助我们完成一些特定任务。

通过插件，我们可以基于 Helm 现有的特性构建新功能，以简化和自动化日常工作流程。

### 8.1 插件介绍

Helm 插件是可以直接从 Helm CLI 访问的外部工具，支持自定义的子命令，而无需修改 Helm 源码。在设计上与 kubectl (Kubernetes CLI) 等工具实现插件系统的方法类似。

例如：

- 下载插件：可以指定自定义协议与 Helm Chart 仓库的通信。如果你有一些自定义身份验证的方法，或者你需要以某种特定方式从 Helm Chart 仓库获取 Helm Chart，那么 “下载插件” 将非常有用。

### 8.2 安装第三方插件

大多第三方插件都是开源的，公开在 GitHub 上。这些插件很多都使用了GitHub的 tag/topic：helm-plugin，通过下面的URL，我们可以很方便的找到所需的 Helm 插件，https://github.com/topics/helm-plugin。

下面是一些在 GitHub 上找到的 Helm 插件示例：

- **helm/helm-2to3**：把 helm2 转换为 helm3
- **jkroepke/helm-secrets**：管理 YAML 格式的 secrets 的插件
- **hickeyma/helm-mapkubeapis**：更新 Helm releases 元数据，包含 Deprecated 的 Kubernetes APIs
- **salesforce/helm-starter**：管理 [helm starters](https://helm.sh/docs/developing_charts/#chart-starter-packs) 的插件，基于 github 仓库创建默认的 helm chart（自定义由 `helm create` 创建的 chart 的文件内容）。

![](./images/plugin.png)



当我们找到所需的 Helm 插件后，就可以安装 Helm 插件了，安装 Helm 插件也很简单，我们以 **salesforce/helm-starter**(https://github.com/salesforce/helm-starter) 为例，只需要运行以下命令就可以安装 Helm 插件。（一般在 Helm 插件的 README.md 页面，都会介绍如何安装以及使用当前 Helm 插件。）

```sh
helm plugin install https://github.com/salesforce/helm-starter.git
```

安装成功后，便可以使用插件了：

```sh
helm starter fetch https://github.com/salesforce/helm-starter-istio.git
helm create banana-service --starter helm-starter-istio/ingress-service
```



### 8.3 构建插件

构建 Helm 插件是一个相当简单的过程，根据需求和插件的复杂性，可能依赖一些编程语言构建插件。然而，许多插件仅仅运行一个基本的 **shell** 命令即可实现 Helm 插件。

**底层实现：**

每个插件都由一个名为 plugin.yaml 的 YAML 文件定义。此文件包含插件元数据和有关调用插件时要运行的命令的信息。

**示例：**

1. 创建一个文件夹

   ```sh
   mkdir hello
   cd hello
   ```

2. 创建 plugin.yaml 

   ```yaml
   name: "hello"
   version: "0.1.0"
   usage: "Say hello"
   description: |-
     This is a demonstration plugin that prints Hello and then exists.
   command: "echo Hello World!"
   ```

   - name：插件的名称
   - version：插件的版本号
   - usage：插件的帮助信息，运行 `helm -h` 的时候会显示
   - command：插件真正执行的命令

3. 安装插件

   ```sh
   helm plugin install ./hello
   
   helm plugin list
   NAME   	VERSION	DESCRIPTION                                                       
   hello  	0.1.0  	This is a demonstration plugin that prints Hello and then exists. 
   ```

4. 运行插件

   ```sh
   helm hello
   ```

   

> 参考资料：
>
> https://new.qq.com/omn/20210831/20210831A0CHOL00.html
>
> http://technosophos.com/2017/03/21/creating-a-helm-plugin.html